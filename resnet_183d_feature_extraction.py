# -*- coding: utf-8 -*-
"""ResNet-183d_feature_extraction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ABXk-eokKYjmahsuG30gnQ3Os5bGVytm
"""

# Data Preprocessing and Uploading
from google.colab import drive
drive.mount('/content/drive')

files,volume = extract_data("/content/drive/MyDrive/internship_KU/Images-FreeSurfer/")

import nibabel as nib
import glob
import numpy as np
import matplotlib.pyplot as plt

def extract_data(filepath):
    files = glob.glob(filepath+"*.gz")
    if not files:
        files = glob.glob(filepath+"*.nii")
    files.sort()
    volumes = [nib.load(file) for file in files]

    return files, volumes


def draw_volume(volume, percentage=0.5, filename=None):
    fig = plt.figure(figsize=[15, 5])

    if isinstance(volume, str):
        volume = nib.load(volume)

    i_x = int(np.floor(volume.shape[0] * percentage))
    i_y = int(np.floor(volume.shape[1] * percentage))
    i_z = int(np.floor(volume.shape[2] * percentage))

    if isinstance(volume, nib.nifti1.Nifti1Image):
        slice_x = np.squeeze(volume.slicer[i_x:i_x + 1, :, :].get_fdata())
        slice_y = np.squeeze(volume.slicer[:, i_y:i_y + 1, :].get_fdata())
        slice_z = np.squeeze(volume.slicer[:, :, i_z:i_z + 1].get_fdata())
    else:
        slice_x = np.squeeze(volume[i_x:i_x + 1, :, :])
        slice_y = np.squeeze(volume[:, i_y:i_y + 1, :])
        slice_z = np.squeeze(volume[:, :, i_z:i_z + 1])

    ax1 = fig.add_subplot(131)
    # ax1.axis("off")
    ax1.imshow(slice_x, cmap='gray')
    ax1.set_title('X_Slice: {}/{}'.format(i_x, volume.shape[0]))

    ax2 = fig.add_subplot(132)
    # ax2.axis("off")
    ax2.imshow(slice_y, cmap='gray')
    ax2.set_title('Y_Slice: {}/{}'.format(i_y, volume.shape[1]))

    ax3 = fig.add_subplot(133)
    # ax3.axis("off")
    ax3.imshow(slice_z, cmap='gray')
    ax3.set_title('Z_Slice: {}/{}'.format(i_z, volume.shape[2]))

    if filename:
        plt.savefig(filename)

    #plt.show()
    return fig

if __name__ == "__main__":
    pass

import torch
import torchvision.models as models
import torchvision.transforms as transforms
import nibabel as nib
import numpy as np
import os
import glob

def get_features(model, x):
    with torch.no_grad():
        # Forward pass until the second-to-last layer (average pooling layer)
        x = model.stem(x)
        x = model.layer1(x)
        x = model.layer2(x)
        x = model.layer3(x)
        x = model.layer4(x)
        x = model.avgpool(x)
        x = torch.flatten(x, 1)
    return x

x = np.zeros(512)
x = x[None, :]
for i in range(512):

  img = nib.load(files[i])

# Sanity Check
  #draw_volume(volume[i], percentage=0.5)

#Convert image
  data = img.get_fdata()

#Rescale to [0,1]
  data = data / 255

#set up normalization
  mean=[0.43216, 0.394666, 0.37645]
  std=[0.22803, 0.22145, 0.216989]


# Add chanels
  data = np.stack([data] * 3, axis=0)

  tensor = torch.from_numpy(data).float()

#normalize
  for channel, mean_value, std_value in zip(tensor, mean, std):
        channel.sub_(mean_value).div_(std_value)

# convert to tensor and add batch size of 1
  tensor = torch.from_numpy(data).float().unsqueeze(0)


# run model
  model = models.video.r3d_18(weights="R3D_18_Weights.DEFAULT")
  model.eval()
  feat = get_features(model, tensor)
  x = np.concatenate([x,feat.numpy()])

import pandas as pd
df = pd.DataFrame(file_id)

df.to_csv('feature_id.csv', index=False)